---
title: "getting_data"
author: "olivier"
date: "3/18/2022"
output: html_document
---

The goal is to get all tracks and train stations off the [Amtrack network](https://en.wikipedia.org/wiki/List_of_Amtrak_routes) and the first step is getting data.

## Amtrack!

### Relations with network="Amtrack"

The First step is collecting data about Amtrack. I went with a query that get all [relations](https://wiki.openstreetmap.org/wiki/Relation). A csv file with the relation id and name but without coordinates was enough because at first we just want to pinpoint the relation that we need without downloding too much from the server. 

I have tuned the request in overpass api then used cURL. 

```{bash}
curl --globoff -o relation_amtrack.csv "http://overpass-api.de/api/interpreter?data=[out:csv(::type,::id,name)];rel[network="Amtrak"];out;"
```

I moved the csv in the `data/` repertory.

### Cleaning the csv

```{r}
relations_amtrack <- read.csv("../Data/relation_amtrack.csv", sep = "\t")
# we can drop relation and clean names
names(relations_amtrack) <- c("rel", "id", "name")
relations_amtrack <- relations_amtrack[, c("id", "name")]      
```

We just need the one with `=`

```{r}
relations_amtrack <- relations_amtrack[grep(pattern = "=", relations_amtrack$name),]
```

Better but we are still facing some trouble:

- we have potential duplicates: see `Amtrak Keystone Service: Harrisburg => Philadelphia` 

- we have two way: see `Seattle => Chicago` and `Chicago => Seattle`

We need to understand why.

Let see how many distinct name we get:

```{r}
unique_track <-  aggregate(data = relations_amtrack,
          id ~ name,
          FUN = function(x) length(unique(x)))

unique_track[order(unique_track$id, decreasing = TRUE),]

sum( unique_track$id > 1 ) # number of track that have more than one relation 
```

Start with one: 

```{r}
relations_amtrack[relations_amtrack$name =="Amtrak Keystone Service: Harrisburg => Philadelphia",]
```

Let's write the multiple relations on a file so we can extract:

```{r}
write.table(relations_amtrack$id[relations_amtrack$name =="Amtrak Keystone Service: Harrisburg => Philadelphia"], 
          "../Data/temp/test.txt", 
          row.names = FALSE,
          col.names=FALSE)
```

Now we can count:

```{bash}
<!-- while read line -->
<!--     do  -->
<!--         echo "[out:csv(::count)];relation(${line});>;out count;" > ../Data/temp/query.osm -->
<!--         wget -O ../Data/temp/${line}.osm --post-file=../Data/temp/query.osm "https://overpass-api.de/api/interpreter" -->
<!--         sleep 10 -->

<!--     done < ../Data/temp/test.txt -->
```

```{r}

list_double <- relations_amtrack$id[relations_amtrack$name =="Amtrak Keystone Service: Harrisburg => Philadelphia"]

query <- paste0("[out:csv(::count)];relation(",list_double[1], ");>;out count;")

download.file("https://overpass-api.de/api/interpreter", method = "wget", extra = "--post-file=../Data/temp/query.osm")

```


This is a bit ugly but it works and the job is done. 
I used this [web](https://overpass-api.de/command_line.html) page as a reference. 

```{r}
list_count <- list.files(path = "../Data/temp/")
list_count <- list_count[grep(pattern = "^[ 0-9]", list_count )]

substring(list_count, 1, 8)

my_path <- "../Data/temp/" 
nb_nodes <- vector(length = 6L)

for (i in 1:length(list_count)) {
    nb_nodes[i] = scan(paste0(my_path,list_count[i]), 
                        skip = 1, 
                        quiet = TRUE)
    print(nb_nodes[i])
}
    
list_count[which.max(nb_nodes)]    

```

